# -*- coding: utf-8 -*-
"""week 3.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1aWqe6wDhddVYaiCu3W92Jw-3k0kB8I3l
"""

# Loadig the required libraries
import numpy as np
import pandas as pd
import time

# Load the clinics dataset
clinics_df = pd.read_csv("clinics.csv")
clinics_df.head()

#1. Tabulate the execution times of each of the individual approaches for computing distance in Python (i.e., run the shared code on your computer, note the times, and tabulate them).

# Extract latitude and longitude columns
latitudes = clinics_df['locLat'].values
longitudes = clinics_df['locLong'].values

# Define the Haversine function
def haversine(lat1, lon1, lat2, lon2):
    MILES = 3959
    lat1, lon1, lat2, lon2 = map(np.deg2rad, [lat1, lon1, lat2, lon2])
    dlat = lat2 - lat1
    dlon = lon2 - lon1
    a = np.sin(dlat / 2)**2 + np.cos(lat1) * np.cos(lat2) * np.sin(dlon / 2)**2
    c = 2 * np.arcsin(np.sqrt(a))
    return MILES * c

# 1. For-loop-based approach
"""
    This approach uses nested loops to calculate the pairwise distances
    between all points. Each latitude and longitude pair is compared
    with every other pair in the dataset.
    """
def compute_distances_loop(latitudes, longitudes):
  num_points = len(latitudes)
  distance_matrix = np.zeros((num_points, num_points))
  for i in range(num_points):
    for j in range(num_points):
      distance_matrix[i, j] = haversine(latitudes[i], longitudes[i], latitudes[j], longitudes[j])
      return distance_matrix

start = time.time()
distances_loop = compute_distances_loop(latitudes, longitudes)
loop_time = time.time() - start

# 2. Apply (Lambda) approach
"""
    This approach uses the pandas 'apply' function with a lambda
    to compute distances row-by-row. It calculates the distance
    between a fixed point and all other points iteratively using
    the Haversine formula.
    """
def compute_distances_apply(df):
    num_points = len(df)
    distance_matrix = np.zeros((num_points, num_points))
    for i in range(num_points):
        distance_matrix[i, :] = df.apply(
            lambda row: haversine(df.loc[i, 'locLat'], df.loc[i, 'locLong'], row['locLat'], row['locLong']), axis=1
        )
    return distance_matrix

start = time.time()
distances_apply = compute_distances_apply(clinics_df)
apply_time = time.time() - start

# 3. Vectorized NumPy approach
"""
    This approach leverages NumPy's vectorized operations to compute
    all pairwise distances at once. By using matrix operations, it
    eliminates the need for explicit loops, making it the fastest
    and most efficient method.
    """
def compute_distances_vectorized(latitudes, longitudes):
    latitudes = np.deg2rad(latitudes)
    longitudes = np.deg2rad(longitudes)
    lat_diff = latitudes[:, np.newaxis] - latitudes
    lon_diff = longitudes[:, np.newaxis] - longitudes
    a = np.sin(lat_diff / 2)**2 + np.cos(latitudes[:, np.newaxis]) * np.cos(latitudes) * np.sin(lon_diff / 2)**2
    c = 2 * np.arcsin(np.sqrt(a))
    distance_matrix = 3959 * c
    return distance_matrix

start = time.time()
distances_vectorized = compute_distances_vectorized(latitudes, longitudes)
vector_time = time.time() - start

# Tabulate execution times
execution_times = pd.DataFrame({
    "Method": ["For-loop", "Apply (Lambda)", "Vectorized (NumPy)"],
    "Execution Time (s)": [loop_time, apply_time, vector_time]
})

# Display the results
print(execution_times)